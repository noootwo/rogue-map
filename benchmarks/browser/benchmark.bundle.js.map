{
  "version": 3,
  "sources": ["../../src/codecs.ts", "../../src/utils.ts", "shims/empty.js", "../../src/persistence/fs.ts", "../../src/persistence/browser.ts", "../../src/persistence/manager.ts", "../../src/PagedBuffer.ts", "../../src/RogueMap.ts", "src/benchmark.ts"],
  "sourcesContent": ["import { Codec } from \"./interfaces\";\n\n/**\n * String Codec: Encodes strings as UTF-8.\n * Variable length.\n */\nexport const StringCodec: Codec<string> = {\n  encode(value: string, buffer: Buffer, offset: number): number {\n    return buffer.write(value, offset);\n  },\n  decode(buffer: Buffer, offset: number, length: number = 0): string {\n    return buffer.toString(\"utf8\", offset, offset + length);\n  },\n  byteLength(value: string): number {\n    return Buffer.byteLength(value);\n  },\n  fixedLength: undefined,\n};\n\n/**\n * Int32 Codec: Encodes numbers as 32-bit integers.\n * Fixed length: 4 bytes.\n */\nexport const Int32Codec: Codec<number> = {\n  encode(value: number, buffer: Buffer, offset: number): number {\n    return buffer.writeInt32LE(value, offset);\n  },\n  decode(buffer: Buffer, offset: number): number {\n    return buffer.readInt32LE(offset);\n  },\n  byteLength(): number {\n    return 4;\n  },\n  fixedLength: 4,\n};\n\n/**\n * Float64 Codec: Encodes numbers as 64-bit doubles.\n * Fixed length: 8 bytes.\n */\nexport const Float64Codec: Codec<number> = {\n  encode(value: number, buffer: Buffer, offset: number): number {\n    return buffer.writeDoubleLE(value, offset);\n  },\n  decode(buffer: Buffer, offset: number): number {\n    return buffer.readDoubleLE(offset);\n  },\n  byteLength(): number {\n    return 8;\n  },\n  fixedLength: 8,\n};\n\n/**\n * JSON Codec: Encodes values as JSON strings.\n * Variable length.\n */\nexport const JSONCodec: Codec<any> = {\n  encode(value: any, buffer: Buffer, offset: number): number {\n    const str = JSON.stringify(value);\n    return buffer.write(str, offset);\n  },\n  decode(buffer: Buffer, offset: number, length: number = 0): any {\n    const str = buffer.toString(\"utf8\", offset, offset + length);\n    return JSON.parse(str);\n  },\n  byteLength(value: any): number {\n    return Buffer.byteLength(JSON.stringify(value));\n  },\n  fixedLength: undefined,\n};\n\n/**\n * Boolean Codec: Encodes booleans as 1 byte (0 or 1).\n * Fixed length: 1 byte.\n */\nexport const BooleanCodec: Codec<boolean> = {\n  encode(value: boolean, buffer: Buffer, offset: number): number {\n    return buffer.writeUInt8(value ? 1 : 0, offset);\n  },\n  decode(buffer: Buffer, offset: number): boolean {\n    return buffer.readUInt8(offset) === 1;\n  },\n  byteLength(): number {\n    return 1;\n  },\n  fixedLength: 1,\n};\n\n/**\n * BigInt64 Codec: Encodes bigints as 64-bit integers.\n * Fixed length: 8 bytes.\n */\nexport const BigInt64Codec: Codec<bigint> = {\n  encode(value: bigint, buffer: Buffer, offset: number): number {\n    return buffer.writeBigInt64LE(value, offset);\n  },\n  decode(buffer: Buffer, offset: number): bigint {\n    return buffer.readBigInt64LE(offset);\n  },\n  byteLength(): number {\n    return 8;\n  },\n  fixedLength: 8,\n};\n\n/**\n * Date Codec: Encodes dates as 64-bit doubles (timestamp).\n * Fixed length: 8 bytes.\n */\nexport const DateCodec: Codec<Date> = {\n  encode(value: Date, buffer: Buffer, offset: number): number {\n    return buffer.writeDoubleLE(value.getTime(), offset);\n  },\n  decode(buffer: Buffer, offset: number): Date {\n    return new Date(buffer.readDoubleLE(offset));\n  },\n  byteLength(): number {\n    return 8;\n  },\n  fixedLength: 8,\n};\n\n/**\n * Buffer Codec: Encodes Buffers directly.\n * Variable length.\n */\nexport const BufferCodec: Codec<Buffer> = {\n  encode(value: Buffer, buffer: Buffer, offset: number): number {\n    return value.copy(buffer, offset);\n  },\n  decode(buffer: Buffer, offset: number, length: number = 0): Buffer {\n    // Return a copy to ensure safety\n    const res = Buffer.allocUnsafe(length);\n    buffer.copy(res, 0, offset, offset + length);\n    return res;\n  },\n  byteLength(value: Buffer): number {\n    return value.length;\n  },\n  fixedLength: undefined,\n};\n\n/**\n * Any Codec: Encodes any type using a prefix byte to identify the type.\n * Supports: Null, Undefined, Boolean, Int32, Float64, String, Date, Buffer, BigInt, JSON.\n */\nexport const AnyCodec: Codec<any> = {\n  encode(value: any, buffer: Buffer, offset: number): number {\n    // Prefix byte for type:\n    // 0: Null/Undefined\n    // 1: Boolean (1 byte)\n    // 2: Int32 (4 bytes)\n    // 3: Float64 (8 bytes)\n    // 4: String (Var)\n    // 5: Date (8 bytes)\n    // 6: JSON (Var)\n    // 7: Buffer (Var)\n    // 8: BigInt (8 bytes)\n\n    if (value === null || value === undefined) {\n      buffer.writeUInt8(0, offset);\n      return 1;\n    }\n\n    if (typeof value === \"boolean\") {\n      buffer.writeUInt8(1, offset);\n      buffer.writeUInt8(value ? 1 : 0, offset + 1);\n      return 2;\n    }\n\n    if (typeof value === \"number\") {\n      if (\n        Number.isInteger(value) &&\n        value >= -2147483648 &&\n        value <= 2147483647\n      ) {\n        buffer.writeUInt8(2, offset);\n        buffer.writeInt32LE(value, offset + 1);\n        return 5;\n      }\n      buffer.writeUInt8(3, offset);\n      buffer.writeDoubleLE(value, offset + 1);\n      return 9;\n    }\n\n    if (typeof value === \"string\") {\n      buffer.writeUInt8(4, offset);\n      const len = buffer.write(value, offset + 1);\n      return 1 + len;\n    }\n\n    if (typeof value === \"bigint\") {\n      buffer.writeUInt8(8, offset);\n      buffer.writeBigInt64LE(value, offset + 1);\n      return 9;\n    }\n\n    if (value instanceof Date) {\n      buffer.writeUInt8(5, offset);\n      buffer.writeDoubleLE(value.getTime(), offset + 1);\n      return 9;\n    }\n\n    if (Buffer.isBuffer(value)) {\n      buffer.writeUInt8(7, offset);\n      value.copy(buffer, offset + 1);\n      return 1 + value.length;\n    }\n\n    // Fallback to JSON\n    buffer.writeUInt8(6, offset);\n    const str = JSON.stringify(value);\n    const len = buffer.write(str, offset + 1);\n    return 1 + len;\n  },\n\n  decode(buffer: Buffer, offset: number, length: number = 0): any {\n    const type = buffer.readUInt8(offset);\n    const dataOffset = offset + 1;\n    const dataLen = length - 1;\n\n    switch (type) {\n      case 0:\n        return null;\n      case 1:\n        return buffer.readUInt8(dataOffset) === 1;\n      case 2:\n        return buffer.readInt32LE(dataOffset);\n      case 3:\n        return buffer.readDoubleLE(dataOffset);\n      case 4:\n        return buffer.toString(\"utf8\", dataOffset, dataOffset + dataLen);\n      case 5:\n        return new Date(buffer.readDoubleLE(dataOffset));\n      case 6:\n        return JSON.parse(\n          buffer.toString(\"utf8\", dataOffset, dataOffset + dataLen),\n        );\n      case 7: {\n        const res = Buffer.allocUnsafe(dataLen);\n        buffer.copy(res, 0, dataOffset, dataOffset + dataLen);\n        return res;\n      }\n      case 8:\n        return buffer.readBigInt64LE(dataOffset);\n      default:\n        return undefined;\n    }\n  },\n\n  byteLength(value: any): number {\n    if (value === null || value === undefined) return 1;\n    if (typeof value === \"boolean\") return 2;\n    if (typeof value === \"number\") {\n      if (\n        Number.isInteger(value) &&\n        value >= -2147483648 &&\n        value <= 2147483647\n      )\n        return 5;\n      return 9;\n    }\n    if (typeof value === \"string\") return 1 + Buffer.byteLength(value);\n    if (typeof value === \"bigint\") return 9;\n    if (value instanceof Date) return 9;\n    if (Buffer.isBuffer(value)) return 1 + value.length;\n    return 1 + Buffer.byteLength(JSON.stringify(value));\n  },\n\n  fixedLength: undefined,\n};\n", "/**\n * FNV-1a hash function for strings.\n * Fast and provides good distribution for short strings.\n *\n * @param str The string to hash.\n * @returns A 32-bit unsigned integer hash.\n */\nexport function fnv1a(str: string): number {\n  let hash = 2166136261;\n  for (let i = 0; i < str.length; i++) {\n    hash ^= str.charCodeAt(i);\n    hash = Math.imul(hash, 16777619);\n  }\n  return hash >>> 0;\n}\n\n/**\n * Thomas Wang's 32-bit integer mix hash function.\n * Optimized for hashing numbers.\n *\n * @param num The number to hash.\n * @returns A 32-bit unsigned integer hash.\n */\nexport function numberHash(num: number): number {\n  // Simple integer hash or just return the number if it fits 32-bit (but distribution matters)\n  // Thomas Wang's 32-bit integer mix function\n  num = ~num + (num << 15);\n  num = num ^ (num >>> 12);\n  num = num + (num << 2);\n  num = num ^ (num >>> 4);\n  num = Math.imul(num, 2057);\n  num = num ^ (num >>> 16);\n  return num >>> 0;\n}\n", "\nexport default {};\nexport const readFileSync = () => {};\nexport const writeFileSync = () => {};\nexport const existsSync = () => false;\nexport const promises = {\n    readFile: async () => {},\n    writeFile: async () => {},\n    unlink: async () => {},\n};\nexport const join = (...args) => args.join('/');\nexport const resolve = (...args) => args.join('/');\nexport const dirname = (p) => p;\n", "import { PersistenceAdapter } from \"./interfaces\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\n\n/**\n * FileSystemAdapter: Persistence adapter for Node.js File System.\n * Supports both sync and async operations.\n */\nexport class FileSystemAdapter implements PersistenceAdapter {\n  async save(data: Buffer, filePath: string): Promise<void> {\n    await fs.promises.mkdir(path.dirname(filePath), { recursive: true });\n    await fs.promises.writeFile(filePath, data);\n  }\n\n  saveSync(data: Buffer, filePath: string): void {\n    fs.mkdirSync(path.dirname(filePath), { recursive: true });\n    fs.writeFileSync(filePath, data);\n  }\n\n  async load(filePath: string): Promise<Buffer | null> {\n    try {\n      return await fs.promises.readFile(filePath);\n    } catch (e: any) {\n      if (e.code === \"ENOENT\") return null;\n      throw e;\n    }\n  }\n\n  loadSync(filePath: string): Buffer | null {\n    try {\n      return fs.readFileSync(filePath);\n    } catch (e: any) {\n      if (e.code === \"ENOENT\") return null;\n      throw e;\n    }\n  }\n}\n", "import { PersistenceAdapter } from \"./interfaces\";\n\n/**\n * IndexedDBAdapter: Persistence adapter for Browser IndexedDB.\n * Suitable for storing large amounts of data asynchronously.\n */\nexport class IndexedDBAdapter implements PersistenceAdapter {\n  private dbName = \"RogueMapDB\";\n  private storeName = \"store\";\n\n  private async openDB(): Promise<IDBDatabase> {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, 1);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result);\n      request.onupgradeneeded = (event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n        db.createObjectStore(this.storeName);\n      };\n    });\n  }\n\n  async save(data: Buffer, key: string): Promise<void> {\n    const db = await this.openDB();\n    return new Promise((resolve, reject) => {\n      const tx = db.transaction(this.storeName, \"readwrite\");\n      const store = tx.objectStore(this.storeName);\n      // IndexedDB can store Blob or ArrayBuffer. Buffer is Uint8Array subclass.\n      const request = store.put(data, key);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve();\n    });\n  }\n\n  saveSync(data: Buffer, key: string): void {\n    throw new Error(\"IndexedDB does not support synchronous operations.\");\n  }\n\n  async load(key: string): Promise<Buffer | null> {\n    const db = await this.openDB();\n    return new Promise((resolve, reject) => {\n      const tx = db.transaction(this.storeName, \"readonly\");\n      const store = tx.objectStore(this.storeName);\n      const request = store.get(key);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => {\n        const result = request.result;\n        if (!result) resolve(null);\n        else resolve(Buffer.from(result));\n      };\n    });\n  }\n\n  loadSync(key: string): Buffer | null {\n    throw new Error(\"IndexedDB does not support synchronous operations.\");\n  }\n}\n\nexport class LocalStorageAdapter implements PersistenceAdapter {\n  save(data: Buffer, key: string): Promise<void> {\n    this.saveSync(data, key);\n    return Promise.resolve();\n  }\n\n  saveSync(data: Buffer, key: string): void {\n    const base64 = data.toString(\"base64\");\n    localStorage.setItem(key, base64);\n  }\n\n  load(key: string): Promise<Buffer | null> {\n    return Promise.resolve(this.loadSync(key));\n  }\n\n  loadSync(key: string): Buffer | null {\n    const base64 = localStorage.getItem(key);\n    if (!base64) return null;\n    return Buffer.from(base64, \"base64\");\n  }\n}\n", "import { PersistenceAdapter, PersistenceType } from \"./interfaces\";\nimport { FileSystemAdapter } from \"./fs\";\nimport { IndexedDBAdapter, LocalStorageAdapter } from \"./browser\";\n\n/**\n * PersistenceManager: Factory for creating persistence adapters.\n */\nexport class PersistenceManager {\n  static getAdapter(type: PersistenceType = \"auto\"): PersistenceAdapter {\n    if (type === \"auto\") {\n      if (\n        typeof process !== \"undefined\" &&\n        process.versions &&\n        process.versions.node\n      ) {\n        return new FileSystemAdapter();\n      }\n      if (typeof indexedDB !== \"undefined\") {\n        return new IndexedDBAdapter();\n      }\n      if (typeof localStorage !== \"undefined\") {\n        return new LocalStorageAdapter();\n      }\n      throw new Error(\"No suitable persistence adapter found.\");\n    }\n\n    switch (type) {\n      case \"fs\":\n        return new FileSystemAdapter();\n      case \"indexeddb\":\n        return new IndexedDBAdapter();\n      case \"localstorage\":\n        return new LocalStorageAdapter();\n      case \"memory\":\n        return {\n          save: async () => {},\n          saveSync: () => {},\n          load: async () => null,\n          loadSync: () => null,\n        };\n      default:\n        throw new Error(`Unknown persistence type: ${type}`);\n    }\n  }\n}\n", "/**\n * PagedBuffer: A wrapper around multiple Node.js Buffers to support sizes > 2GB/4GB.\n *\n * Uses a fixed page size (default 1GB) to split data across multiple buffers.\n * Provides a Buffer-like API for seamless integration.\n */\nexport class PagedBuffer {\n  // 1GB Page Size (2^30)\n  // Using 1GB avoids signed 32-bit issues within a page and fits comfortably in Node's limits.\n  static readonly PAGE_SIZE = 1073741824;\n  static readonly PAGE_SHIFT = 30;\n  static readonly PAGE_MASK = 0x3fffffff;\n\n  private pages: Buffer[];\n  private _length: number;\n  private singlePage: Buffer | null; // Optimization for single-page scenarios\n\n  constructor(initialSize: number) {\n    this._length = initialSize;\n    const numPages = Math.ceil(initialSize / PagedBuffer.PAGE_SIZE);\n    this.pages = new Array(numPages);\n\n    let remaining = initialSize;\n    for (let i = 0; i < numPages; i++) {\n      const size = Math.min(remaining, PagedBuffer.PAGE_SIZE);\n      this.pages[i] = Buffer.allocUnsafe(size);\n      remaining -= size;\n    }\n\n    this.singlePage = numPages === 1 ? this.pages[0] : null;\n  }\n\n  getSinglePage(): Buffer | null {\n    return this.singlePage;\n  }\n\n  get length(): number {\n    return this._length;\n  }\n\n  static allocUnsafe(size: number): PagedBuffer {\n    return new PagedBuffer(size);\n  }\n\n  resize(newSize: number): void {\n    if (newSize === this._length) return;\n\n    const oldPages = this.pages;\n    const numPages = Math.ceil(newSize / PagedBuffer.PAGE_SIZE);\n    this.pages = new Array(numPages);\n    this._length = newSize;\n\n    let remaining = newSize;\n    for (let i = 0; i < numPages; i++) {\n      const size = Math.min(remaining, PagedBuffer.PAGE_SIZE);\n      if (i < oldPages.length) {\n        // Reuse or Resize existing page\n        if (oldPages[i].length >= size) {\n          this.pages[i] = oldPages[i].subarray(0, size);\n        } else {\n          const newPage = Buffer.allocUnsafe(size);\n          oldPages[i].copy(newPage);\n          this.pages[i] = newPage;\n        }\n      } else {\n        // New page\n        this.pages[i] = Buffer.allocUnsafe(size);\n      }\n      remaining -= size;\n    }\n\n    this.singlePage = numPages === 1 ? this.pages[0] : null;\n  }\n\n  readUInt8(offset: number): number {\n    if (this.singlePage) return this.singlePage.readUInt8(offset);\n\n    const pageIdx = Math.floor(offset / PagedBuffer.PAGE_SIZE);\n    const pageOffset = offset % PagedBuffer.PAGE_SIZE;\n    return this.pages[pageIdx].readUInt8(pageOffset);\n  }\n\n  writeUInt8(value: number, offset: number): void {\n    if (this.singlePage) {\n      this.singlePage.writeUInt8(value, offset);\n      return;\n    }\n\n    const pageIdx = Math.floor(offset / PagedBuffer.PAGE_SIZE);\n    const pageOffset = offset % PagedBuffer.PAGE_SIZE;\n    this.pages[pageIdx].writeUInt8(value, pageOffset);\n  }\n\n  readInt32LE(offset: number): number {\n    if (this.singlePage) return this.singlePage.readInt32LE(offset);\n\n    const pageIdx = Math.floor(offset / PagedBuffer.PAGE_SIZE);\n    const pageOffset = offset % PagedBuffer.PAGE_SIZE;\n\n    // Fast path: fits in one page\n    if (pageOffset + 4 <= PagedBuffer.PAGE_SIZE) {\n      return this.pages[pageIdx].readInt32LE(pageOffset);\n    }\n\n    // Slow path: cross-boundary\n    return this.readMultiByte(offset, 4).readInt32LE(0);\n  }\n\n  writeInt32LE(value: number, offset: number): void {\n    if (this.singlePage) {\n      this.singlePage.writeInt32LE(value, offset);\n      return;\n    }\n\n    const pageIdx = Math.floor(offset / PagedBuffer.PAGE_SIZE);\n    const pageOffset = offset % PagedBuffer.PAGE_SIZE;\n\n    if (pageOffset + 4 <= PagedBuffer.PAGE_SIZE) {\n      this.pages[pageIdx].writeInt32LE(value, pageOffset);\n      return;\n    }\n\n    const buf = Buffer.allocUnsafe(4);\n    buf.writeInt32LE(value, 0);\n    this.writeMultiByte(buf, offset);\n  }\n\n  readUInt32LE(offset: number): number {\n    if (this.singlePage) return this.singlePage.readUInt32LE(offset);\n\n    const pageIdx = Math.floor(offset / PagedBuffer.PAGE_SIZE);\n    const pageOffset = offset % PagedBuffer.PAGE_SIZE;\n\n    if (pageOffset + 4 <= PagedBuffer.PAGE_SIZE) {\n      return this.pages[pageIdx].readUInt32LE(pageOffset);\n    }\n\n    return this.readMultiByte(offset, 4).readUInt32LE(0);\n  }\n\n  writeUInt32LE(value: number, offset: number): void {\n    if (this.singlePage) {\n      this.singlePage.writeUInt32LE(value, offset);\n      return;\n    }\n\n    const pageIdx = Math.floor(offset / PagedBuffer.PAGE_SIZE);\n    const pageOffset = offset % PagedBuffer.PAGE_SIZE;\n\n    if (pageOffset + 4 <= PagedBuffer.PAGE_SIZE) {\n      this.pages[pageIdx].writeUInt32LE(value, pageOffset);\n      return;\n    }\n\n    const buf = Buffer.allocUnsafe(4);\n    buf.writeUInt32LE(value, 0);\n    this.writeMultiByte(buf, offset);\n  }\n\n  // Helper for cross-boundary reads\n  private readMultiByte(offset: number, length: number): Buffer {\n    const res = Buffer.allocUnsafe(length);\n    this.copy(res, 0, offset, offset + length);\n    return res;\n  }\n\n  // Helper for cross-boundary writes\n  private writeMultiByte(buf: Buffer, offset: number): void {\n    let currentOffset = offset;\n    let bufOffset = 0;\n    let remaining = buf.length;\n\n    while (remaining > 0) {\n      const pageIdx = Math.floor(currentOffset / PagedBuffer.PAGE_SIZE);\n      const pageOffset = currentOffset % PagedBuffer.PAGE_SIZE;\n      const toWrite = Math.min(remaining, PagedBuffer.PAGE_SIZE - pageOffset);\n\n      buf.copy(this.pages[pageIdx], pageOffset, bufOffset, bufOffset + toWrite);\n\n      currentOffset += toWrite;\n      bufOffset += toWrite;\n      remaining -= toWrite;\n    }\n  }\n\n  copy(\n    target: Buffer | Uint8Array,\n    targetStart: number,\n    sourceStart: number,\n    sourceEnd: number,\n  ): number {\n    if (this.singlePage) {\n      return this.singlePage.copy(\n        target as Buffer,\n        targetStart,\n        sourceStart,\n        sourceEnd,\n      );\n    }\n\n    let currentSource = sourceStart;\n    let currentTarget = targetStart;\n    let remaining = sourceEnd - sourceStart;\n    const total = remaining;\n\n    while (remaining > 0) {\n      const pageIdx = Math.floor(currentSource / PagedBuffer.PAGE_SIZE);\n      const pageOffset = currentSource % PagedBuffer.PAGE_SIZE;\n      const toCopy = Math.min(remaining, PagedBuffer.PAGE_SIZE - pageOffset);\n\n      this.pages[pageIdx].copy(\n        target as Buffer,\n        currentTarget,\n        pageOffset,\n        pageOffset + toCopy,\n      );\n\n      currentSource += toCopy;\n      currentTarget += toCopy;\n      remaining -= toCopy;\n    }\n    return total;\n  }\n\n  // Special copy method for resizing (PagedBuffer -> PagedBuffer)\n  copyToPaged(\n    target: PagedBuffer,\n    targetStart: number,\n    sourceStart: number,\n    sourceEnd: number,\n  ): void {\n    let currentSource = sourceStart;\n    let currentTarget = targetStart;\n    let remaining = sourceEnd - sourceStart;\n\n    while (remaining > 0) {\n      const srcPageIdx = Math.floor(currentSource / PagedBuffer.PAGE_SIZE);\n      const srcPageOffset = currentSource % PagedBuffer.PAGE_SIZE;\n\n      const tgtPageIdx = Math.floor(currentTarget / PagedBuffer.PAGE_SIZE);\n      const tgtPageOffset = currentTarget % PagedBuffer.PAGE_SIZE;\n\n      const toCopy = Math.min(\n        remaining,\n        PagedBuffer.PAGE_SIZE - srcPageOffset,\n        PagedBuffer.PAGE_SIZE - tgtPageOffset,\n      );\n\n      this.pages[srcPageIdx].copy(\n        target.pages[tgtPageIdx],\n        tgtPageOffset,\n        srcPageOffset,\n        srcPageOffset + toCopy,\n      );\n\n      currentSource += toCopy;\n      currentTarget += toCopy;\n      remaining -= toCopy;\n    }\n  }\n\n  compare(\n    target: Buffer,\n    targetStart: number,\n    targetEnd: number,\n    sourceStart: number,\n    sourceEnd: number,\n  ): number {\n    if (this.singlePage) {\n      return this.singlePage.compare(\n        target,\n        targetStart,\n        targetEnd,\n        sourceStart,\n        sourceEnd,\n      );\n    }\n\n    // Compare THIS (source) with TARGET (standard Buffer)\n    // Used for key comparison\n    const len = sourceEnd - sourceStart;\n    const targetLen = targetEnd - targetStart;\n    if (len !== targetLen) return len - targetLen;\n\n    let currentSource = sourceStart;\n    let currentTarget = targetStart;\n    let remaining = len;\n\n    while (remaining > 0) {\n      const pageIdx = Math.floor(currentSource / PagedBuffer.PAGE_SIZE);\n      const pageOffset = currentSource % PagedBuffer.PAGE_SIZE;\n      const toCheck = Math.min(remaining, PagedBuffer.PAGE_SIZE - pageOffset);\n\n      const res = this.pages[pageIdx].compare(\n        target,\n        currentTarget,\n        currentTarget + toCheck,\n        pageOffset,\n        pageOffset + toCheck,\n      );\n\n      if (res !== 0) return res;\n\n      currentSource += toCheck;\n      currentTarget += toCheck;\n      remaining -= toCheck;\n    }\n\n    return 0;\n  }\n\n  // For direct writing of buffers (keys/values)\n  writeBuffer(buf: Buffer, offset: number): void {\n    if (this.singlePage) {\n      // Optimization: Single page\n      // Use copy logic from Buffer\n      // buf.copy(this.singlePage, offset)\n      // Wait, writeBuffer signature: writeBuffer(buf, offset) means \"write buf INTO this at offset\"\n      // Buffer.copy(target, targetStart, sourceStart, sourceEnd)\n      // So: buf.copy(this.singlePage, offset)\n      buf.copy(this.singlePage, offset);\n      return;\n    }\n    this.writeMultiByte(buf, offset);\n  }\n\n  // For reading buffers (decoding)\n  readBuffer(offset: number, length: number): Buffer {\n    if (this.singlePage) {\n      return this.singlePage.subarray(offset, offset + length);\n    }\n\n    // Optimization: Single page within multi-page\n    const pageIdx = Math.floor(offset / PagedBuffer.PAGE_SIZE);\n    const pageOffset = offset % PagedBuffer.PAGE_SIZE;\n    if (pageOffset + length <= PagedBuffer.PAGE_SIZE) {\n      return this.pages[pageIdx].subarray(pageOffset, pageOffset + length);\n    }\n    return this.readMultiByte(offset, length);\n  }\n}\n", "import { Codec } from \"./interfaces\";\nimport { AnyCodec } from \"./codecs\";\nimport { fnv1a, numberHash } from \"./utils\";\nimport {\n  PersistenceOptions,\n  CompactionOptions,\n  PersistenceAdapter,\n} from \"./persistence/interfaces\";\nimport { PersistenceManager } from \"./persistence/manager\";\nimport { PagedBuffer } from \"./PagedBuffer\";\n\n/**\n * Configuration options for creating a RogueMap instance.\n */\nexport interface RogueMapOptions<K, V> {\n  /**\n   * Initial capacity of the hash table (number of buckets).\n   * Defaults to 16384.\n   */\n  capacity?: number;\n  /**\n   * Initial size of the off-heap buffer in bytes.\n   * Defaults to 10MB.\n   */\n  initialMemory?: number;\n  /**\n   * Codec for encoding/decoding keys.\n   * Defaults to StringCodec.\n   */\n  keyCodec?: Codec<K>;\n  /**\n   * Codec for encoding/decoding values.\n   * Defaults to JSONCodec.\n   */\n  valueCodec?: Codec<V>;\n  /**\n   * Custom hash function for keys.\n   * Defaults to FNV1a for strings.\n   */\n  hasher?: (key: K) => number;\n  /**\n   * Configuration for persistence (saving/loading to disk/storage).\n   */\n  persistence?: PersistenceOptions;\n  /**\n   * Configuration for auto-compaction (garbage collection of deleted items).\n   */\n  compaction?: CompactionOptions;\n  /**\n   * Size of the LRU Cache for hot items (number of items).\n   * Set to 0 to disable. Defaults to 0.\n   */\n  cacheSize?: number; // LRU Cache size (0 = disabled)\n}\n\nconst DEFAULT_CAPACITY = 16384;\nconst DEFAULT_MEMORY = 10 * 1024 * 1024; // 10MB\nconst FLAG_ACTIVE = 1;\nconst FLAG_DELETED = 2;\n\n/**\n * RogueMap: A high-performance, off-heap hash map for Node.js.\n *\n * Stores data in a Node.js Buffer to reduce GC overhead and heap usage.\n * Supports custom codecs, persistence, and an optional LRU cache for hot reads.\n *\n * @template K Type of keys (must be supported by keyCodec)\n * @template V Type of values (must be supported by valueCodec)\n */\nexport class RogueMap<K = any, V = any> {\n  private capacity: number;\n  private capacityMask: number; // Optimization: mask for modulo operations (capacity - 1)\n  private buffer: PagedBuffer;\n  private rawBuffer: Buffer | null = null; // Optimization: Direct access for single-page buffers\n  private buckets: Float64Array; // Changed to Float64Array to support >2GB offsets\n  private hashes: Int32Array;\n  private states: Uint8Array;\n  private writeOffset: number;\n  private _size: number = 0;\n  private _deletedCount: number = 0;\n\n  private keyCodec: Codec<K>;\n  private valueCodec: Codec<V>;\n  private hasher: (key: K) => number;\n\n  private persistence?: PersistenceOptions;\n  private compaction: CompactionOptions;\n  private adapter?: PersistenceAdapter;\n  private saveTimer?: NodeJS.Timeout | number;\n\n  private cache?: Map<K, V>;\n  private cacheSize: number;\n\n  private tempKeyBuffer: Buffer = Buffer.allocUnsafe(1024); // Reusable buffer for key comparison\n\n  /**\n   * Creates a new RogueMap instance.\n   *\n   * @param options Configuration options\n   */\n  constructor(options: RogueMapOptions<K, V> = {}) {\n    // Ensure capacity is power of 2 for fast modulo\n    let cap = options.capacity || DEFAULT_CAPACITY;\n    if ((cap & (cap - 1)) !== 0) {\n      cap = Math.pow(2, Math.ceil(Math.log2(cap)));\n    }\n    this.capacity = cap;\n    this.capacityMask = cap - 1;\n\n    this.buckets = new Float64Array(this.capacity);\n    this.hashes = new Int32Array(this.capacity);\n    this.states = new Uint8Array(this.capacity); // 0=Empty, 1=Active, 2=Deleted\n    this.buffer = PagedBuffer.allocUnsafe(\n      options.initialMemory || DEFAULT_MEMORY,\n    );\n    this.rawBuffer = this.buffer.getSinglePage();\n    this.writeOffset = 1; // Start at 1 because 0 in buckets means empty\n\n    // Default to AnyCodec for maximum flexibility if no codec is provided\n    this.keyCodec = options.keyCodec || (AnyCodec as unknown as Codec<K>);\n    this.valueCodec = options.valueCodec || (AnyCodec as unknown as Codec<V>);\n\n    this.cacheSize = options.cacheSize || 0;\n    if (this.cacheSize > 0) {\n      this.cache = new Map();\n    }\n\n    if (options.hasher) {\n      this.hasher = options.hasher;\n    } else {\n      // Default hasher inference\n      this.hasher = (key: K) => {\n        if (typeof key === \"string\") return fnv1a(key);\n        if (typeof key === \"number\") return numberHash(key);\n        if (Buffer.isBuffer(key)) return fnv1a(key.toString(\"binary\"));\n        return fnv1a(String(key));\n      };\n    }\n\n    // Persistence & Compaction Setup\n    this.persistence = options.persistence;\n    this.compaction = {\n      autoCompact: true,\n      threshold: 0.3,\n      minSize: 1000,\n      ...options.compaction,\n    };\n\n    if (this.persistence) {\n      this.adapter = PersistenceManager.getAdapter(this.persistence.type);\n\n      // Try synchronous load if configured (Node.js default)\n      if (this.persistence.syncLoad !== false) {\n        try {\n          const savedData = this.adapter.loadSync(this.persistence.path);\n          if (savedData) {\n            this.loadFromBuffer(savedData);\n          }\n        } catch (e: any) {\n          // Ignore sync load errors if it's because method not implemented (browser)\n          // But if syncLoad is explicitly true, we might want to throw?\n          // For 'auto', we try and ignore.\n        }\n      }\n\n      // Start auto-save timer\n      if (this.persistence.saveInterval && this.persistence.saveInterval > 0) {\n        this.saveTimer = setInterval(\n          () => this.save(),\n          this.persistence.saveInterval,\n        );\n        // Unref to not block process exit in Node\n        if (typeof (this.saveTimer as any).unref === \"function\") {\n          (this.saveTimer as any).unref();\n        }\n      }\n    }\n  }\n\n  /**\n   * Initialize persistence asynchronously.\n   * Required for environments like IndexedDB where synchronous access is not possible.\n   * Loads the map state from the configured persistence storage.\n   */\n  async init(): Promise<void> {\n    if (!this.persistence || !this.adapter) return;\n\n    const savedData = await this.adapter.load(this.persistence.path);\n    if (savedData) {\n      this.loadFromBuffer(savedData);\n    }\n  }\n\n  /**\n   * Manually save the map state to the configured persistence storage.\n   * Note: Auto-save can also be configured via options.\n   */\n  async save(): Promise<void> {\n    if (!this.persistence || !this.adapter) return;\n    const data = this.serialize();\n    await this.adapter.save(data, this.persistence.path);\n  }\n\n  private loadFromBuffer(data: Buffer) {\n    // This logic is similar to deserialize but reuses the current instance\n    // We assume data format is valid\n    let cursor = 0;\n\n    // Magic\n    const magic = data.toString(\"utf8\", cursor, cursor + 5);\n    cursor += 5;\n    if (magic !== \"ROGUE\") throw new Error(\"Invalid RogueMap format\");\n\n    // Version\n    const version = data.readUInt8(cursor);\n    cursor += 1;\n    if (version !== 1)\n      throw new Error(`Unsupported RogueMap version: ${version}`);\n\n    // Capacity\n    const capacity = data.readUInt32LE(cursor);\n    cursor += 4;\n\n    // Size\n    const size = data.readUInt32LE(cursor);\n    cursor += 4;\n\n    // WriteOffset\n    const writeOffset = data.readUInt32LE(cursor);\n    cursor += 4;\n\n    // BufferLength\n    const bufferLength = data.readUInt32LE(cursor);\n    cursor += 4;\n\n    // Restore Buckets\n    const bucketsSize = capacity * 4;\n    const bucketsBuffer = data.subarray(cursor, cursor + bucketsSize);\n\n    // We need to convert Int32Array (from buffer) to Float64Array\n    // Since persisted format uses 4 bytes per bucket, it assumes offsets fit in 32-bit.\n    // If we load a legacy format or a format that was saved when offsets were small, this is fine.\n    // If we want to support >2GB persistence, we need to upgrade the format version.\n    // For now, assume version 1 uses 32-bit buckets.\n\n    // Copy to aligned buffer to satisfy Int32Array alignment requirements\n    const alignedBucketsBuffer = Buffer.allocUnsafe(bucketsSize);\n    bucketsBuffer.copy(alignedBucketsBuffer);\n\n    // Create Float64Array for internal use\n    const savedBuckets = new Float64Array(capacity);\n    const tempInt32 = new Int32Array(\n      alignedBucketsBuffer.buffer,\n      alignedBucketsBuffer.byteOffset,\n      bucketsSize / 4,\n    );\n    for (let i = 0; i < capacity; i++) {\n      savedBuckets[i] = tempInt32[i];\n    }\n\n    cursor += bucketsSize;\n\n    // Update instance state\n    this.capacity = capacity;\n    this.capacityMask = capacity - 1;\n    this.buckets = savedBuckets;\n    this.hashes = new Int32Array(capacity);\n    this.states = new Uint8Array(capacity);\n    this._size = size;\n    this.writeOffset = writeOffset;\n    this.buffer = PagedBuffer.allocUnsafe(bufferLength);\n    this.buffer.writeBuffer(data.subarray(cursor, cursor + bufferLength), 0);\n    this.rawBuffer = this.buffer.getSinglePage();\n\n    this._deletedCount = 0;\n\n    // REBUILD HASHES AND STATES\n    for (let i = 0; i < this.capacity; i++) {\n      const offset = this.buckets[i];\n      if (offset !== 0) {\n        const flag = this.buffer.readUInt8(offset);\n        if (flag === FLAG_ACTIVE) {\n          this.states[i] = FLAG_ACTIVE;\n          const hash = this.buffer.readInt32LE(offset + 1);\n          this.hashes[i] = hash;\n        } else if (flag === FLAG_DELETED) {\n          this.states[i] = FLAG_DELETED;\n          const hash = this.buffer.readInt32LE(offset + 1);\n          this.hashes[i] = hash;\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns the number of elements in the map.\n   */\n  get size(): number {\n    return this._size;\n  }\n\n  /**\n   * Sets the value for the key in the map.\n   *\n   * @param key The key of the element to add to the RogueMap object.\n   * @param value The value of the element to add to the RogueMap object.\n   */\n  set(key: K, value: V): void {\n    if (this.cache) {\n      // Update cache on write\n      if (this.cache.has(key)) {\n        // Refresh\n        this.cache.delete(key);\n        this.cache.set(key, value);\n      } else {\n        // Add new? Maybe not. Cache is usually for \"read hot\", not \"write hot\".\n        // But if we just wrote it, we likely read it soon.\n        if (this.cache.size >= this.cacheSize) {\n          const oldestKey = this.cache.keys().next().value;\n          if (oldestKey !== undefined) this.cache.delete(oldestKey);\n        }\n        this.cache.set(key, value);\n      }\n    }\n\n    if (this._size >= this.capacity * 0.75) {\n      this.resize(this.capacity * 2, this.buffer.length * 2);\n    }\n\n    const hash = this.hasher(key) | 0;\n\n    try {\n      this.put(key, value, hash);\n    } catch (e: any) {\n      if (e.message === \"RogueMap: Out of memory (Buffer full)\") {\n        // Calculate needed size roughly or just double repeatedly\n        // A safer bet is to double until it fits, but we can't retry infinite times.\n        // Let's try to resize to Math.max(current * 2, needed + overhead)\n        // But we don't know 'needed' easily here without encoding.\n\n        // Simple fix: Retry logic loop\n        let retries = 0;\n        while (retries < 3) {\n          this.resize(this.capacity, this.buffer.length * 2);\n          try {\n            this.put(key, value, hash);\n            break; // Success\n          } catch (retryErr: any) {\n            if (retryErr.message === \"RogueMap: Out of memory (Buffer full)\") {\n              retries++;\n              continue;\n            }\n            throw retryErr;\n          }\n        }\n        if (retries === 3) throw e; // Give up\n      } else if (e.message === \"RogueMap: Hash table full\") {\n        // Should be caught by load factor check, but safe fallback\n        this.resize(this.capacity * 2, this.buffer.length * 2);\n        this.put(key, value, hash);\n      } else {\n        throw e;\n      }\n    }\n\n    this.checkCompaction();\n  }\n\n  private put(key: K, value: V, hash: number): void {\n    const buckets = this.buckets;\n    const states = this.states;\n    const hashes = this.hashes;\n    const mask = this.capacityMask;\n\n    // PRE-ENCODE KEY: Avoid re-encoding in the loop\n    const keyLen = this.keyCodec.byteLength(key);\n    // Ensure temp buffer is large enough\n    if (this.tempKeyBuffer.length < keyLen) {\n      this.tempKeyBuffer = Buffer.allocUnsafe(\n        Math.max(keyLen, this.tempKeyBuffer.length * 2),\n      );\n    }\n    this.keyCodec.encode(key, this.tempKeyBuffer, 0);\n\n    let index = Math.abs(hash) & mask;\n    const start_index = index;\n    let tombstoneIndex = -1;\n\n    // === OPTIMIZED PATH: Single Page Buffer (Direct Access) ===\n    if (this.rawBuffer) {\n      const raw = this.rawBuffer;\n      const tempKey = this.tempKeyBuffer;\n      const keyFixed = this.keyCodec.fixedLength;\n      const valFixed = this.valueCodec.fixedLength;\n\n      while (true) {\n        const offset = buckets[index];\n\n        if (offset === 0) {\n          // Found empty slot\n          if (tombstoneIndex !== -1) {\n            index = tombstoneIndex;\n          }\n          // INLINE WRITE ENTRY\n          const valLen = this.valueCodec.byteLength(value);\n          let entrySize = 5; // Flag(1) + Hash(4)\n          if (keyFixed === undefined) entrySize += 4;\n          if (valFixed === undefined) entrySize += 4;\n          entrySize += keyLen + valLen;\n\n          if (this.writeOffset + entrySize > raw.length) {\n            throw new Error(\"RogueMap: Out of memory (Buffer full)\");\n          }\n\n          let cursor = this.writeOffset;\n          raw[cursor++] = FLAG_ACTIVE;\n\n          // Manual Write Hash (Int32LE)\n          raw[cursor] = hash & 0xff;\n          raw[cursor + 1] = (hash >>> 8) & 0xff;\n          raw[cursor + 2] = (hash >>> 16) & 0xff;\n          raw[cursor + 3] = (hash >>> 24) & 0xff;\n          cursor += 4;\n\n          if (keyFixed === undefined) {\n            // Manual Write KeyLen (Int32LE)\n            raw[cursor] = keyLen & 0xff;\n            raw[cursor + 1] = (keyLen >>> 8) & 0xff;\n            raw[cursor + 2] = (keyLen >>> 16) & 0xff;\n            raw[cursor + 3] = (keyLen >>> 24) & 0xff;\n            cursor += 4;\n          }\n          if (valFixed === undefined) {\n            // Manual Write ValLen (Int32LE)\n            raw[cursor] = valLen & 0xff;\n            raw[cursor + 1] = (valLen >>> 8) & 0xff;\n            raw[cursor + 2] = (valLen >>> 16) & 0xff;\n            raw[cursor + 3] = (valLen >>> 24) & 0xff;\n            cursor += 4;\n          }\n\n          // Write Key (Copy from temp buffer - FAST)\n          if (keyLen > 0) {\n            tempKey.copy(raw, cursor, 0, keyLen);\n            cursor += keyLen;\n          }\n\n          // Write Val (Encode directly to buffer - FAST)\n          if (valLen > 0) {\n            this.valueCodec.encode(value, raw, cursor);\n            cursor += valLen;\n          }\n\n          this.buckets[index] = this.writeOffset;\n          this.hashes[index] = hash;\n          this.states[index] = FLAG_ACTIVE;\n          this.writeOffset += entrySize;\n          this._size++;\n          return;\n        }\n\n        const state = states[index];\n\n        if (state === FLAG_DELETED) {\n          if (tombstoneIndex === -1) tombstoneIndex = index;\n        } else if (state === FLAG_ACTIVE) {\n          if (hashes[index] === hash) {\n            // INLINE COMPARE\n            let cursor = offset + 5;\n            let storedKeyLen = keyLen;\n            if (keyFixed === undefined) {\n              // Manual Read KeyLen (Int32LE)\n              storedKeyLen =\n                raw[cursor] |\n                (raw[cursor + 1] << 8) |\n                (raw[cursor + 2] << 16) |\n                (raw[cursor + 3] << 24);\n              cursor += 4;\n            }\n            if (valFixed === undefined) {\n              cursor += 4; // Skip val len\n            }\n\n            if (storedKeyLen === keyLen) {\n              // Manual Compare\n              let match = true;\n              for (let k = 0; k < keyLen; k++) {\n                if (raw[cursor + k] !== tempKey[k]) {\n                  match = false;\n                  break;\n                }\n              }\n\n              if (match) {\n                // MATCH FOUND - UPDATE\n                raw[offset] = FLAG_DELETED;\n                states[index] = FLAG_DELETED;\n                this._deletedCount++;\n\n                // Append new\n                // COPY PASTE WRITE LOGIC (To avoid function call)\n                const valLen = this.valueCodec.byteLength(value);\n                let entrySize = 5;\n                if (keyFixed === undefined) entrySize += 4;\n                if (valFixed === undefined) entrySize += 4;\n                entrySize += keyLen + valLen;\n\n                if (this.writeOffset + entrySize > raw.length) {\n                  throw new Error(\"RogueMap: Out of memory (Buffer full)\");\n                }\n\n                let wCursor = this.writeOffset;\n                raw[wCursor++] = FLAG_ACTIVE;\n\n                // Manual Write Hash\n                raw[wCursor] = hash & 0xff;\n                raw[wCursor + 1] = (hash >>> 8) & 0xff;\n                raw[wCursor + 2] = (hash >>> 16) & 0xff;\n                raw[wCursor + 3] = (hash >>> 24) & 0xff;\n                wCursor += 4;\n\n                if (keyFixed === undefined) {\n                  // Manual Write KeyLen\n                  raw[wCursor] = keyLen & 0xff;\n                  raw[wCursor + 1] = (keyLen >>> 8) & 0xff;\n                  raw[wCursor + 2] = (keyLen >>> 16) & 0xff;\n                  raw[wCursor + 3] = (keyLen >>> 24) & 0xff;\n                  wCursor += 4;\n                }\n                if (valFixed === undefined) {\n                  // Manual Write ValLen\n                  raw[wCursor] = valLen & 0xff;\n                  raw[wCursor + 1] = (valLen >>> 8) & 0xff;\n                  raw[wCursor + 2] = (valLen >>> 16) & 0xff;\n                  raw[wCursor + 3] = (valLen >>> 24) & 0xff;\n                  wCursor += 4;\n                }\n\n                if (keyLen > 0) {\n                  tempKey.copy(raw, wCursor, 0, keyLen);\n                  wCursor += keyLen;\n                }\n                if (valLen > 0) {\n                  this.valueCodec.encode(value, raw, wCursor);\n                  wCursor += valLen;\n                }\n\n                this.buckets[index] = this.writeOffset;\n                this.hashes[index] = hash;\n                this.states[index] = FLAG_ACTIVE;\n                this.writeOffset += entrySize;\n                return;\n              }\n            }\n          }\n        }\n\n        index = (index + 1) & mask;\n        if (index === start_index) {\n          throw new Error(\"RogueMap: Hash table full\");\n        }\n      }\n    }\n\n    // === SLOW PATH: Multi-Page Buffer ===\n    while (true) {\n      const offset = buckets[index];\n\n      if (offset === 0) {\n        // Found empty slot\n        if (tombstoneIndex !== -1) {\n          index = tombstoneIndex; // Reuse tombstone if found\n        }\n        this.writeEntry(index, key, value, hash);\n        this._size++;\n        return;\n      }\n\n      // Check if deleted or match\n      const state = states[index];\n\n      if (state === FLAG_DELETED) {\n        if (tombstoneIndex === -1) tombstoneIndex = index;\n      } else if (state === FLAG_ACTIVE) {\n        // Active entry, check key\n        if (hashes[index] === hash) {\n          if (this.keyMatchesPreEncoded(offset, keyLen)) {\n            // Mark old as deleted\n            this.buffer.writeUInt8(FLAG_DELETED, offset);\n            states[index] = FLAG_DELETED; // Update state\n            this._deletedCount++;\n\n            // Append new entry and update bucket\n            this.writeEntry(index, key, value, hash);\n            return;\n          }\n        }\n      }\n\n      // Fast Modulo\n      index = (index + 1) & mask;\n      if (index === start_index) {\n        throw new Error(\"RogueMap: Hash table full\");\n      }\n    }\n  }\n\n  private checkCompaction() {\n    if (!this.compaction.autoCompact) return;\n\n    // Check if we have enough items to care\n    if (this._size + this._deletedCount < (this.compaction.minSize || 1000))\n      return;\n\n    const ratio = this._deletedCount / (this._size + this._deletedCount);\n    if (ratio > (this.compaction.threshold || 0.3)) {\n      this.compact();\n    }\n  }\n\n  private resize(newCapacity: number, newMemory: number) {\n    const oldBuffer = this.buffer;\n    const oldLimit = this.writeOffset;\n\n    // Ensure power of 2\n    if ((newCapacity & (newCapacity - 1)) !== 0) {\n      newCapacity = Math.pow(2, Math.ceil(Math.log2(newCapacity)));\n    }\n\n    this.capacity = newCapacity;\n    this.capacityMask = newCapacity - 1;\n    this.buckets = new Float64Array(this.capacity);\n    this.hashes = new Int32Array(this.capacity);\n    this.states = new Uint8Array(this.capacity);\n    this.buffer = PagedBuffer.allocUnsafe(newMemory);\n    this.rawBuffer = this.buffer.getSinglePage();\n    this.writeOffset = 1;\n    this._size = 0;\n\n    let cursor = 1;\n    while (cursor < oldLimit) {\n      const flag = oldBuffer.readUInt8(cursor);\n\n      // Layout: [Flag(1)] [Hash(4)] [KeyLen(4)?] [ValLen(4)?] [Key] [Val]\n      const hash = oldBuffer.readInt32LE(cursor + 1);\n\n      let entryLen = 5; // Flag + Hash\n\n      let keySize: number, valSize: number;\n      let kLenSize = 0,\n        vLenSize = 0;\n\n      if (this.keyCodec.fixedLength !== undefined) {\n        keySize = this.keyCodec.fixedLength;\n      } else {\n        keySize = oldBuffer.readInt32LE(cursor + 5);\n        kLenSize = 4;\n      }\n\n      if (this.valueCodec.fixedLength !== undefined) {\n        valSize = this.valueCodec.fixedLength;\n      } else {\n        valSize = oldBuffer.readInt32LE(cursor + 5 + kLenSize);\n        vLenSize = 4;\n      }\n\n      entryLen += kLenSize + vLenSize + keySize + valSize;\n\n      if (flag === FLAG_ACTIVE) {\n        // Copy to new buffer via put()\n        // We decode to get the key for hashing\n        const keyStart = cursor + 5 + kLenSize + vLenSize;\n\n        // Read key buffer from old PagedBuffer\n        const keyBuf = oldBuffer.readBuffer(keyStart, keySize);\n        const key = this.keyCodec.decode(keyBuf, 0, keySize);\n\n        // Read val buffer from old PagedBuffer\n        const valStart = keyStart + keySize;\n        const valBuf = oldBuffer.readBuffer(valStart, valSize);\n        const value = this.valueCodec.decode(valBuf, 0, valSize);\n\n        this.put(key, value, hash);\n      }\n\n      cursor += entryLen;\n    }\n  }\n\n  /**\n   * Compacts the map by removing deleted entries and resizing the buffer to fit the active data.\n   * This is useful to reclaim memory after many deletions.\n   */\n  compact(): void {\n    // Resize to current capacity but optimize buffer size\n    // Calculate required size for active entries\n    let requiredSize = 1; // Initial offset\n    let cursor = 1;\n    while (cursor < this.writeOffset) {\n      const flag = this.buffer.readUInt8(cursor);\n\n      let entryLen = 5; // Flag + Hash\n\n      let keySize: number, valSize: number;\n      let kLenSize = 0,\n        vLenSize = 0;\n\n      if (this.keyCodec.fixedLength !== undefined) {\n        keySize = this.keyCodec.fixedLength;\n      } else {\n        keySize = this.buffer.readInt32LE(cursor + 5);\n        kLenSize = 4;\n      }\n\n      if (this.valueCodec.fixedLength !== undefined) {\n        valSize = this.valueCodec.fixedLength;\n      } else {\n        valSize = this.buffer.readInt32LE(cursor + 5 + kLenSize);\n        vLenSize = 4;\n      }\n\n      const totalLen = entryLen + kLenSize + vLenSize + keySize + valSize;\n\n      if (flag === FLAG_ACTIVE) {\n        requiredSize += totalLen;\n      }\n\n      cursor += totalLen;\n    }\n\n    // Add 20% margin or minimum\n    const newBufferSize = Math.max(requiredSize * 1.2, 1024);\n    this.resize(this.capacity, newBufferSize);\n    this._deletedCount = 0; // Reset deleted count\n\n    // Trigger save if persistence enabled\n    if (this.persistence && this.adapter) {\n      this.save().catch(console.error);\n    }\n  }\n\n  /**\n   * Serializes the map state into a Buffer.\n   * The returned buffer contains the full state of the map and can be saved to disk or transmitted.\n   * Use RogueMap.deserialize() to restore the map from this buffer.\n   */\n  serialize(): Buffer {\n    // Format:\n    // [Magic: ROGUE(5)]\n    // [Version: 1(1)]\n    // [Capacity: 4]\n    // [Size: 4]\n    // [WriteOffset: 4]\n    // [BufferLength: 4]\n    // [Buckets: Capacity * 4]\n    // [Buffer: BufferLength]\n\n    // It is recommended to compact before serialize to save space, but we don't enforce it here.\n\n    const headerSize = 5 + 1 + 4 + 4 + 4 + 4;\n    const bucketsSize = this.capacity * 4;\n    const bufferSize = this.writeOffset; // Only save used buffer\n\n    const totalSize = headerSize + bucketsSize + bufferSize;\n\n    // Check limit\n    if (totalSize > 2 * 1024 * 1024 * 1024) {\n      // Node.js Buffer size limit is usually 2GB or 4GB.\n      // If we exceed 2GB, we risk failure depending on version.\n      // We will try to alloc. If it fails, it throws.\n    }\n\n    const result = Buffer.allocUnsafe(totalSize);\n\n    let cursor = 0;\n\n    // Magic\n    result.write(\"ROGUE\", cursor);\n    cursor += 5;\n\n    // Version\n    result.writeUInt8(1, cursor);\n    cursor += 1;\n\n    // Capacity\n    result.writeUInt32LE(this.capacity, cursor);\n    cursor += 4;\n\n    // Size\n    result.writeUInt32LE(this._size, cursor);\n    cursor += 4;\n\n    // WriteOffset\n    result.writeUInt32LE(this.writeOffset, cursor);\n    cursor += 4;\n\n    // BufferLength (stored)\n    result.writeUInt32LE(bufferSize, cursor);\n    cursor += 4;\n\n    // Buckets\n    // Convert Float64Array to Int32Array buffer for compatibility\n    // WARNING: If offsets > 2GB, this will truncate/wrap and corrupt data!\n    // For now, we assume serialize is only used for < 2GB maps.\n    // TODO: Upgrade format version to support 64-bit offsets.\n    const tempInt32 = new Int32Array(this.capacity);\n    for (let i = 0; i < this.capacity; i++) tempInt32[i] = this.buckets[i];\n\n    const bucketsBuffer = Buffer.from(\n      tempInt32.buffer,\n      tempInt32.byteOffset,\n      tempInt32.byteLength,\n    );\n    bucketsBuffer.copy(result, cursor);\n    cursor += bucketsSize;\n\n    // Buffer\n    // Need to copy from PagedBuffer to result Buffer\n    this.buffer.copy(result, cursor, 0, bufferSize);\n\n    return result;\n  }\n\n  /**\n   * Creates a new RogueMap instance from a serialized buffer.\n   *\n   * @param data The buffer containing the serialized map data.\n   * @param options Configuration options for the new instance.\n   */\n  static deserialize<K, V>(\n    data: Buffer,\n    options: RogueMapOptions<K, V> = {},\n  ): RogueMap<K, V> {\n    const map = new RogueMap<K, V>(options);\n    map.loadFromBuffer(data);\n    return map;\n  }\n\n  /**\n   * Returns the value associated to the key, or undefined if there is none.\n   *\n   * @param key The key of the element to return.\n   */\n  get(key: K): V | undefined {\n    // Check Cache\n    if (this.cache) {\n      const val = this.cache.get(key);\n      if (val !== undefined) {\n        // LRU: Refresh (delete and re-add)\n        this.cache.delete(key);\n        this.cache.set(key, val);\n        return val;\n      }\n    }\n\n    const hash = this.hasher(key) | 0;\n    const buckets = this.buckets;\n    const states = this.states;\n    const hashes = this.hashes;\n    const mask = this.capacityMask;\n\n    let index = Math.abs(hash) & mask;\n    let start_index = index;\n\n    // PRE-ENCODE KEY for keyMatchesPreEncoded\n    const keyLen = this.keyCodec.byteLength(key);\n    if (this.tempKeyBuffer.length < keyLen) {\n      this.tempKeyBuffer = Buffer.allocUnsafe(\n        Math.max(keyLen, this.tempKeyBuffer.length * 2),\n      );\n    }\n    this.keyCodec.encode(key, this.tempKeyBuffer, 0);\n\n    // === OPTIMIZED PATH ===\n    if (this.rawBuffer) {\n      const raw = this.rawBuffer;\n      const tempKey = this.tempKeyBuffer;\n      const keyFixed = this.keyCodec.fixedLength;\n      const valFixed = this.valueCodec.fixedLength;\n\n      while (true) {\n        const offset = buckets[index];\n        if (offset === 0) return undefined;\n\n        if (states[index] === FLAG_ACTIVE) {\n          if (hashes[index] === hash) {\n            // INLINE COMPARE\n            let cursor = offset + 5;\n            let storedKeyLen = keyLen;\n            if (keyFixed === undefined) {\n              // Manual Read KeyLen\n              storedKeyLen =\n                raw[cursor] |\n                (raw[cursor + 1] << 8) |\n                (raw[cursor + 2] << 16) |\n                (raw[cursor + 3] << 24);\n              cursor += 4;\n            }\n            if (valFixed === undefined) {\n              cursor += 4; // Skip val len\n            }\n\n            if (storedKeyLen === keyLen) {\n              // Manual Compare\n              let match = true;\n              for (let k = 0; k < keyLen; k++) {\n                if (raw[cursor + k] !== tempKey[k]) {\n                  match = false;\n                  break;\n                }\n              }\n\n              if (match) {\n                // MATCH! READ VALUE INLINE\n                let vCursor = offset + 5;\n                if (keyFixed === undefined) vCursor += 4;\n\n                let valLen: number;\n                if (valFixed !== undefined) {\n                  valLen = valFixed;\n                } else {\n                  // Manual Read ValLen\n                  valLen =\n                    raw[vCursor] |\n                    (raw[vCursor + 1] << 8) |\n                    (raw[vCursor + 2] << 16) |\n                    (raw[vCursor + 3] << 24);\n                  vCursor += 4;\n                }\n\n                vCursor += keyLen; // Skip Key\n\n                // Read Val\n                // Use subarray to be safe with codecs expecting buffer from 0\n                const valBuf = raw.subarray(vCursor, vCursor + valLen);\n                const val = this.valueCodec.decode(valBuf, 0, valLen);\n\n                // Update Cache\n                if (this.cache) {\n                  if (this.cache.size >= this.cacheSize) {\n                    const oldestKey = this.cache.keys().next().value;\n                    if (oldestKey !== undefined) this.cache.delete(oldestKey);\n                  }\n                  this.cache.set(key, val);\n                }\n                return val;\n              }\n            }\n          }\n        }\n\n        index = (index + 1) & mask;\n        if (index === start_index) return undefined;\n      }\n    }\n\n    while (true) {\n      const offset = buckets[index];\n      if (offset === 0) return undefined;\n\n      // FAST PATH\n      if (states[index] === FLAG_ACTIVE) {\n        if (hashes[index] === hash) {\n          // Only now we read buffer\n          if (this.keyMatchesPreEncoded(offset, keyLen)) {\n            const val = this.readValue(offset);\n            // Update Cache\n            if (this.cache) {\n              if (this.cache.size >= this.cacheSize) {\n                // Evict oldest (first key)\n                const oldestKey = this.cache.keys().next().value;\n                if (oldestKey !== undefined) this.cache.delete(oldestKey);\n              }\n              this.cache.set(key, val);\n            }\n            return val;\n          }\n        }\n      }\n\n      index = (index + 1) & mask;\n      if (index === start_index) return undefined;\n    }\n  }\n\n  /**\n   * Returns a boolean asserting whether a value has been associated to the key in the RogueMap object or not.\n   *\n   * @param key The key of the element to test for presence.\n   */\n  has(key: K): boolean {\n    const hash = this.hasher(key) | 0;\n    const buckets = this.buckets;\n    const states = this.states;\n    const hashes = this.hashes;\n    const mask = this.capacityMask;\n\n    let index = Math.abs(hash) & mask;\n    let start_index = index;\n\n    // PRE-ENCODE KEY\n    const keyLen = this.keyCodec.byteLength(key);\n    if (this.tempKeyBuffer.length < keyLen) {\n      this.tempKeyBuffer = Buffer.allocUnsafe(\n        Math.max(keyLen, this.tempKeyBuffer.length * 2),\n      );\n    }\n    this.keyCodec.encode(key, this.tempKeyBuffer, 0);\n\n    // === OPTIMIZED PATH ===\n    if (this.rawBuffer) {\n      const raw = this.rawBuffer;\n      const tempKey = this.tempKeyBuffer;\n      const keyFixed = this.keyCodec.fixedLength;\n      const valFixed = this.valueCodec.fixedLength;\n\n      while (true) {\n        const offset = buckets[index];\n        if (offset === 0) return false;\n\n        if (states[index] === FLAG_ACTIVE) {\n          if (hashes[index] === hash) {\n            // INLINE COMPARE\n            let cursor = offset + 5;\n            let storedKeyLen = keyLen;\n            if (keyFixed === undefined) {\n              // Manual Read KeyLen\n              storedKeyLen =\n                raw[cursor] |\n                (raw[cursor + 1] << 8) |\n                (raw[cursor + 2] << 16) |\n                (raw[cursor + 3] << 24);\n              cursor += 4;\n            }\n            if (valFixed === undefined) cursor += 4;\n\n            if (storedKeyLen === keyLen) {\n              // Manual Compare\n              let match = true;\n              for (let k = 0; k < keyLen; k++) {\n                if (raw[cursor + k] !== tempKey[k]) {\n                  match = false;\n                  break;\n                }\n              }\n\n              if (match) {\n                return true;\n              }\n            }\n          }\n        }\n\n        index = (index + 1) & mask;\n        if (index === start_index) return false;\n      }\n    }\n\n    while (true) {\n      const offset = buckets[index];\n      if (offset === 0) return false;\n\n      // FAST PATH\n      if (states[index] === FLAG_ACTIVE) {\n        if (hashes[index] === hash) {\n          if (this.keyMatchesPreEncoded(offset, keyLen)) return true;\n        }\n      }\n\n      index = (index + 1) & mask;\n      if (index === start_index) return false;\n    }\n  }\n\n  /**\n   * Removes the specified element from the RogueMap object.\n   * Returns true if an element in the RogueMap object existed and has been removed, or false if the element does not exist.\n   *\n   * @param key The key of the element to remove.\n   */\n  delete(key: K): boolean {\n    if (this.cache) {\n      this.cache.delete(key);\n    }\n\n    const hash = this.hasher(key) | 0;\n    const buckets = this.buckets;\n    const states = this.states;\n    const hashes = this.hashes;\n    const mask = this.capacityMask;\n\n    let index = Math.abs(hash) & mask;\n    let start_index = index;\n\n    // PRE-ENCODE KEY\n    const keyLen = this.keyCodec.byteLength(key);\n    if (this.tempKeyBuffer.length < keyLen) {\n      this.tempKeyBuffer = Buffer.allocUnsafe(\n        Math.max(keyLen, this.tempKeyBuffer.length * 2),\n      );\n    }\n    this.keyCodec.encode(key, this.tempKeyBuffer, 0);\n\n    // === OPTIMIZED PATH ===\n    if (this.rawBuffer) {\n      const raw = this.rawBuffer;\n      const tempKey = this.tempKeyBuffer;\n      const keyFixed = this.keyCodec.fixedLength;\n      const valFixed = this.valueCodec.fixedLength;\n\n      while (true) {\n        const offset = buckets[index];\n        if (offset === 0) return false;\n\n        if (states[index] === FLAG_ACTIVE) {\n          if (hashes[index] === hash) {\n            // INLINE COMPARE\n            let cursor = offset + 5;\n            let storedKeyLen = keyLen;\n            if (keyFixed === undefined) {\n              // Manual Read KeyLen\n              storedKeyLen =\n                raw[cursor] |\n                (raw[cursor + 1] << 8) |\n                (raw[cursor + 2] << 16) |\n                (raw[cursor + 3] << 24);\n              cursor += 4;\n            }\n            if (valFixed === undefined) cursor += 4;\n\n            if (storedKeyLen === keyLen) {\n              // Manual Compare\n              let match = true;\n              for (let k = 0; k < keyLen; k++) {\n                if (raw[cursor + k] !== tempKey[k]) {\n                  match = false;\n                  break;\n                }\n              }\n\n              if (match) {\n                // MATCH! DELETE INLINE\n                raw[offset] = FLAG_DELETED;\n                states[index] = FLAG_DELETED;\n                this._size--;\n                this._deletedCount++;\n                this.checkCompaction();\n                return true;\n              }\n            }\n          }\n        }\n\n        index = (index + 1) & mask;\n        if (index === start_index) return false;\n      }\n    }\n\n    while (true) {\n      const offset = buckets[index];\n      if (offset === 0) return false;\n\n      // FAST PATH\n      if (states[index] === FLAG_ACTIVE) {\n        if (hashes[index] === hash) {\n          if (this.keyMatchesPreEncoded(offset, keyLen)) {\n            this.buffer.writeUInt8(FLAG_DELETED, offset);\n            states[index] = FLAG_DELETED; // Update state\n            this._size--;\n            this._deletedCount++;\n            this.checkCompaction();\n            return true;\n          }\n        }\n      }\n\n      index = (index + 1) & mask;\n      if (index === start_index) return false;\n    }\n  }\n\n  /**\n   * Removes all elements from the RogueMap object.\n   */\n  clear(): void {\n    if (this.cache) {\n      this.cache.clear();\n    }\n    this.buckets.fill(0);\n    this.hashes.fill(0);\n    this.states.fill(0);\n    this.writeOffset = 1;\n    this._size = 0;\n    this._deletedCount = 0; // Add this\n  }\n\n  private writeEntry(index: number, key: K, value: V, hash: number) {\n    // Calculate size\n    const keySize = this.keyCodec.byteLength(key);\n    const valSize = this.valueCodec.byteLength(value);\n\n    const keyFixed = this.keyCodec.fixedLength !== undefined;\n    const valFixed = this.valueCodec.fixedLength !== undefined;\n\n    // Layout: [Flag(1)] [Hash(4)] [KeyLen(4)?] [ValLen(4)?] [Key] [Val]\n    let entrySize = 5; // Flag + Hash\n    if (!keyFixed) entrySize += 4;\n    if (!valFixed) entrySize += 4;\n    entrySize += keySize + valSize;\n\n    // Check buffer space\n    if (this.writeOffset + entrySize > this.buffer.length) {\n      throw new Error(\"RogueMap: Out of memory (Buffer full)\");\n    }\n\n    const offset = this.writeOffset;\n    let cursor = offset;\n\n    // Write Flag\n    this.buffer.writeUInt8(FLAG_ACTIVE, cursor);\n    cursor += 1;\n\n    // Write Hash\n    this.buffer.writeInt32LE(hash, cursor);\n    cursor += 4;\n\n    // Write Key Len\n    if (!keyFixed) {\n      this.buffer.writeInt32LE(keySize, cursor);\n      cursor += 4;\n    }\n\n    // Write Val Len\n    if (!valFixed) {\n      this.buffer.writeInt32LE(valSize, cursor);\n      cursor += 4;\n    }\n\n    // Write Key\n    // Use temp buffer to ensure compatibility with Codec interfaces that expect Buffer\n    if (keySize > 0) {\n      const keyBuf = Buffer.allocUnsafe(keySize);\n      this.keyCodec.encode(key, keyBuf, 0);\n      this.buffer.writeBuffer(keyBuf, cursor);\n      cursor += keySize;\n    }\n\n    // Write Val\n    if (valSize > 0) {\n      const valBuf = Buffer.allocUnsafe(valSize);\n      this.valueCodec.encode(value, valBuf, 0);\n      this.buffer.writeBuffer(valBuf, cursor);\n      cursor += valSize;\n    }\n\n    // Update state\n    this.writeOffset += entrySize;\n    this.buckets[index] = offset;\n    this.hashes[index] = hash;\n    this.states[index] = FLAG_ACTIVE;\n  }\n\n  private keyMatchesPreEncoded(offset: number, keyLen: number): boolean {\n    let cursor = offset + 5; // Skip Flag(1) + Hash(4)\n\n    let keySize: number;\n    if (this.keyCodec.fixedLength !== undefined) {\n      keySize = this.keyCodec.fixedLength;\n    } else {\n      keySize = this.buffer.readInt32LE(cursor);\n      cursor += 4;\n    }\n\n    // Skip ValLen if present\n    if (this.valueCodec.fixedLength === undefined) {\n      cursor += 4;\n    }\n\n    // Optimization: Compare byte length first\n    if (keyLen !== keySize) return false;\n\n    // Zero-Allocation Compare: Use pre-encoded key\n    return (\n      this.buffer.compare(\n        this.tempKeyBuffer,\n        0,\n        keyLen,\n        cursor,\n        cursor + keySize,\n      ) === 0\n    );\n  }\n\n  private keyMatches(offset: number, key: K): boolean {\n    // Deprecated in favor of keyMatchesPreEncoded, keeping just in case or for testing\n    // Logic is same as before\n    let cursor = offset + 5; // Skip Flag(1) + Hash(4)\n\n    let keySize: number;\n    if (this.keyCodec.fixedLength !== undefined) {\n      keySize = this.keyCodec.fixedLength;\n    } else {\n      keySize = this.buffer.readInt32LE(cursor);\n      cursor += 4;\n    }\n\n    if (this.valueCodec.fixedLength === undefined) {\n      cursor += 4;\n    }\n\n    const len = this.keyCodec.byteLength(key);\n    if (len !== keySize) return false;\n\n    if (len <= this.tempKeyBuffer.length) {\n      this.keyCodec.encode(key, this.tempKeyBuffer, 0);\n      return (\n        this.buffer.compare(\n          this.tempKeyBuffer,\n          0,\n          len,\n          cursor,\n          cursor + keySize,\n        ) === 0\n      );\n    }\n\n    const temp = Buffer.allocUnsafe(len);\n    this.keyCodec.encode(key, temp, 0);\n    return this.buffer.compare(temp, 0, len, cursor, cursor + keySize) === 0;\n  }\n\n  private readValue(offset: number): V {\n    let cursor = offset + 5; // Skip Flag(1) + Hash(4)\n\n    // Read/Skip KeyLen\n    let keySize: number;\n    if (this.keyCodec.fixedLength !== undefined) {\n      keySize = this.keyCodec.fixedLength;\n    } else {\n      keySize = this.buffer.readInt32LE(cursor);\n      cursor += 4;\n    }\n\n    // Read ValLen\n    let valSize: number;\n    if (this.valueCodec.fixedLength !== undefined) {\n      valSize = this.valueCodec.fixedLength;\n    } else {\n      valSize = this.buffer.readInt32LE(cursor);\n      cursor += 4;\n    }\n\n    // Skip Key Data\n    cursor += keySize;\n\n    // Read Val buffer\n    const valBuf = this.buffer.readBuffer(cursor, valSize);\n    return this.valueCodec.decode(valBuf, 0, valSize);\n  }\n\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element in the RogueMap object in insertion order.\n   * Note: The order is based on internal buffer layout, which is roughly insertion order but affected by deletions and updates.\n   */\n  *entries(): IterableIterator<[K, V]> {\n    let cursor = 1;\n    while (cursor < this.writeOffset) {\n      const flag = this.buffer.readUInt8(cursor);\n\n      // Layout: [Flag(1)] [Hash(4)] [KeyLen(4)?] [ValLen(4)?] [Key] [Val]\n      let entryLen = 5;\n\n      let keySize: number, valSize: number;\n      let kLenSize = 0,\n        vLenSize = 0;\n\n      if (this.keyCodec.fixedLength !== undefined) {\n        keySize = this.keyCodec.fixedLength;\n      } else {\n        keySize = this.buffer.readInt32LE(cursor + 5);\n        kLenSize = 4;\n      }\n\n      if (this.valueCodec.fixedLength !== undefined) {\n        valSize = this.valueCodec.fixedLength;\n      } else {\n        valSize = this.buffer.readInt32LE(cursor + 5 + kLenSize);\n        vLenSize = 4;\n      }\n\n      entryLen += kLenSize + vLenSize + keySize + valSize;\n\n      if (flag === FLAG_ACTIVE) {\n        const keyStart = cursor + 5 + kLenSize + vLenSize;\n        const keyBuf = this.buffer.readBuffer(keyStart, keySize);\n        const key = this.keyCodec.decode(keyBuf, 0, keySize);\n\n        const valStart = keyStart + keySize;\n        const valBuf = this.buffer.readBuffer(valStart, valSize);\n        const value = this.valueCodec.decode(valBuf, 0, valSize);\n\n        yield [key, value];\n      }\n\n      cursor += entryLen;\n    }\n  }\n\n  /**\n   * Returns a new Iterator object that contains the keys for each element in the RogueMap object.\n   */\n  *keys(): IterableIterator<K> {\n    for (const [key] of this.entries()) {\n      yield key;\n    }\n  }\n\n  /**\n   * Returns a new Iterator object that contains the values for each element in the RogueMap object.\n   */\n  *values(): IterableIterator<V> {\n    for (const [_, value] of this.entries()) {\n      yield value;\n    }\n  }\n\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element in the RogueMap object.\n   */\n  [Symbol.iterator](): IterableIterator<[K, V]> {\n    return this.entries();\n  }\n\n  /**\n   * Executes a provided function once per each key/value pair in the RogueMap object.\n   *\n   * @param callback Function to execute for each element.\n   * @param thisArg Value to use as this when executing callback.\n   */\n  forEach(\n    callback: (value: V, key: K, map: RogueMap<K, V>) => void,\n    thisArg?: any,\n  ): void {\n    for (const [key, value] of this.entries()) {\n      callback.call(thisArg, value, key, this);\n    }\n  }\n}\n", "\nimport { RogueMap } from \"../../../src/RogueMap\";\nimport { Int32Codec, StringCodec } from \"../../../src/codecs\";\n\n// Buffer is provided globally via CDN\ndeclare const Buffer: any;\n\n\nconst outputDiv = document.getElementById(\"output\")!;\nconst btnRun = document.getElementById(\"btnRun\") as HTMLButtonElement;\n\nfunction log(msg: string, type: \"info\" | \"success\" | \"error\" = \"info\") {\n  const line = document.createElement(\"div\");\n  line.textContent = msg;\n  if (type === \"success\") line.className = \"success\";\n  if (type === \"error\") line.className = \"error\";\n  outputDiv.appendChild(line);\n  outputDiv.scrollTop = outputDiv.scrollHeight;\n}\n\nfunction clearLog() {\n  outputDiv.innerHTML = \"\";\n}\n\nasync function runBenchmark() {\n  btnRun.disabled = true;\n  clearLog();\n  log(\"Starting benchmark...\", \"running\");\n\n  const countSelect = document.getElementById(\"itemCount\") as HTMLSelectElement;\n  const COUNT = parseInt(countSelect.value, 10);\n\n  try {\n    log(`Initializing RogueMap with ${COUNT.toLocaleString()} items...`);\n    \n    // 1. In-Memory Performance\n    log(`\\n--- In-Memory Performance ---`);\n    const map = new RogueMap({\n      capacity: COUNT * 1.5,\n      initialMemory: COUNT * 64, // Pre-alloc to avoid resize noise\n      keyCodec: StringCodec,\n      valueCodec: Int32Codec,\n      persistence: { type: \"indexeddb\", path: \"benchmark-db\" }\n    });\n\n    // SET\n    const startSet = performance.now();\n    for (let i = 0; i < COUNT; i++) {\n      map.set(`key:${i}`, i);\n    }\n    const endSet = performance.now();\n    log(`SET: ${(endSet - startSet).toFixed(2)}ms (${Math.round(COUNT / ((endSet - startSet)/1000))} ops/sec)`, \"success\");\n\n    // GET\n    const startGet = performance.now();\n    let sum = 0;\n    for (let i = 0; i < COUNT; i++) {\n      const val = map.get(`key:${i}`);\n      if (val !== undefined) sum += val;\n    }\n    const endGet = performance.now();\n    log(`GET: ${(endGet - startGet).toFixed(2)}ms (${Math.round(COUNT / ((endGet - startGet)/1000))} ops/sec)`, \"success\");\n\n    // 2. Persistence (IndexedDB)\n    log(`\\n--- Persistence (IndexedDB) ---`);\n    log(`Saving to IndexedDB... (This is async)`);\n    const startSave = performance.now();\n    await map.save();\n    const endSave = performance.now();\n    log(`SAVE: ${(endSave - startSave).toFixed(2)}ms`, \"success\");\n\n    log(`Clearing memory and reloading...`);\n    const map2 = new RogueMap({\n      keyCodec: StringCodec,\n      valueCodec: Int32Codec,\n      persistence: { type: \"indexeddb\", path: \"benchmark-db\" }\n    });\n    \n    const startLoad = performance.now();\n    await map2.init();\n    const endLoad = performance.now();\n    log(`LOAD: ${(endLoad - startLoad).toFixed(2)}ms`, \"success\");\n    log(`Map size after load: ${map2.size}`);\n\n    if (map2.size !== COUNT) {\n      log(`ERROR: Size mismatch! Expected ${COUNT}, got ${map2.size}`, \"error\");\n    } else {\n      log(`Verification passed.`, \"success\");\n    }\n\n  } catch (e: any) {\n    log(`Error: ${e.message}`, \"error\");\n    console.error(e);\n  } finally {\n    btnRun.disabled = false;\n  }\n}\n\nasync function clearData() {\n  try {\n    const req = indexedDB.deleteDatabase(\"RogueMapDB\");\n    req.onsuccess = () => {\n        log(\"Database cleared.\", \"success\");\n    };\n    req.onerror = () => {\n        log(\"Failed to clear database.\", \"error\");\n    };\n  } catch(e) {\n      log(\"Error clearing: \" + e);\n  }\n}\n\n// Expose to window\n(window as any).runBenchmark = runBenchmark;\n(window as any).clearData = clearData;\n"],
  "mappings": "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",
  "names": ["len"]
}
